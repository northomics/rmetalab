#' Simple and quick wrapper of ComplexHeatmap::pheatmap,
#'
#' For quick and easy heatmap plot from data matrix and meta info, with only limited parameters exposed.
#' Take advantage of the multiple annotation, easier to implement. The pheatmap:pheatmap is not compatible with markdown document and shiny apps (the ouput postion of the plot is random), thereofore using ComplexHeatmap::pheatmap instead, which is a direct translation of the pheatmap:pheatmap
#' heatmaply::heatmaply is used  to produce an interactive d3 heatmap when
#'
#' @param matrix a data.frame/matrix
#' @param scale The default is "none", scaling method, options of c("none","row", "column")
#' @param column_cluster Boolean, Switch to do column clustering of not

#' @param column_meta a data.frame, 1st as column names of the matrix, from 2nd as grouping,supports multiple grouping mark, will map to colors automatically, Null or NA means no mapping
#' @param row_meta a data.frame, 1st as row names of the matrix, from 2nd as grouping, supports multiple grouping mark, will map to colors automatically,Null or NA means no mapping
#'
#' @param color a vector of colors, could be generated by any method
#'
#' @return a plot of complex heatmap
#'
#' @examples
#' test_data <- generate_test_data()
#' quickpheatmap(test_data$matrix)
#' quickpheatmap(test_data$matrix, interactive = TRUE)
#' quickpheatmap(test_data$matrix, color = rainbow(100))
#' quickpheatmap(test_data$matrix,column_cluster = FALSE)
#' quickpheatmap(test_data$matrix,column_cluster = FALSE,scale = "column")
#' quickpheatmap(test_data$matrix,column_cluster = FALSE,scale = "column",column_meta = test_data$meta )
#' quickpheatmap(test_data$matrix,column_cluster = TRUE,scale = "row",column_meta = test_data$meta )
#' quickpheatmap(test_data$matrix,column_cluster = TRUE,scale = "row",column_meta = test_data$meta,interactive = TRUE )

#'
#' @export
#'
#'


quickpheatmap <- function(matrix,
                         column_cluster = TRUE,
                         column_meta = NULL ,
                         row_meta = NULL,
                         scale = "row",
                         show_rownames  =  FALSE,
                         interactive =  FALSE,
                         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)){


  matrix <- as.matrix(matrix)
  matrix[is.infinite(matrix)] <- NA # in case there is infinite values

  if(!is.null(row_meta)){
    row_meta <- row_meta[match(rownames(matrix),row_meta[,1]),]
    rownames(row_meta) <- row_meta[,1]
    row_meta <- row_meta[,-1, drop = FALSE]
  }else{
    row_meta <- NA
  }

  if(!is.null(column_meta)){
    column_meta <- column_meta[match(colnames(matrix),column_meta[,1]),]
    rownames(column_meta) <- column_meta[,1]
    column_meta <- column_meta[,-1, drop = FALSE]
  }else{
    column_meta<- NA
  }


  if(interactive){

      if(column_cluster){
        dendrogram = "both"
        Colv =TRUE
      }else{
        dendrogram = "row"
        Colv = NULL
      }

     if(is.na(row_meta) && is.na(column_meta)){
       p <- heatmaply::heatmaply(matrix,
                                 Colv  = Colv,
                                 scale = scale,
                                 dendrogram =  dendrogram,
                                 colors = color)
     }else if(!is.na(column_meta) && is.na(row_meta)){
       # if only column grouping information provided
       p <-  heatmaply::heatmaply(matrix,
                                 Colv  = Colv,
                                 scale = scale,
                                 colors = color,
                                 dendrogram =  dendrogram,
                                 col_side_colors = column_meta)

     }else if(is.na(column_meta)  && !is.na(row_meta)){
       # if only row grouping information provided
       p <-  heatmaply::heatmaply(matrix,
                                 Colv  = Colv,
                                 scale = scale,
                                 colors = color,
                                 dendrogram =  dendrogram,
                                 row_side_colors = row_meta)
     }else{
      p <-  heatmaply::heatmaply(matrix,
                                 Colv  = Colv,
                                 scale = scale,
                                 colors = color,
                                 dendrogram =  dendrogram,
                                 col_side_colors = column_meta,
                                 row_side_colors = row_meta)
     }

  }else{
    p <- ComplexHeatmap::pheatmap(matrix,
                  cluster_cols = column_cluster,
                  scale = scale,
                  annotation_col = column_meta,
                  annotation_row = row_meta,
                  color = color,
                  show_rownames = show_rownames,
                  border_color = NA)
  }


  return(p)
}
